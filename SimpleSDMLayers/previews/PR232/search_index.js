var documenterSearchIndex = {"docs":
[{"location":"overloads/#Overloads","page":"Overloads","title":"Overloads","text":"","category":"section"},{"location":"overloads/","page":"Overloads","title":"Overloads","text":"Base.:-\nBase.:*\nBase.:/\nBase.:+\nBase.:==\nBase.abs\nBase.convert\nBase.copy\nBase.eachindex\nBase.eltype\nBase.exp\nBase.exp10\nBase.exp2\nBase.expm1\nBase.extrema\nBase.getindex\nBase.hcat\nBase.isequal\nBase.IteratorsMD.CartesianIndices\nBase.keys\nBase.log\nBase.log10\nBase.log1p\nBase.log2\nBase.max\nBase.maximum\nBase.min\nBase.minimum\nBase.replace\nBase.replace!\nBase.show\nBase.similar\nBase.size\nBase.sqrt\nBase.stride\nBase.sum\nBase.values\nBase.vcat\nSimpleSDMLayers._layers_are_compatible\nSimpleSDMLayers.mask!\nStatistics.mean\nStatistics.median\nStatistics.quantile\nStatistics.std","category":"page"},{"location":"overloads/#SimpleSDMLayers.mask!","page":"Overloads","title":"SimpleSDMLayers.mask!","text":"mask!(layer::SDMLayer, template::SDMLayer)\n\nUpdates the positions in the first layer to be those that have a value in the second layer.\n\n\n\n\n\n","category":"function"},{"location":"overloads/#Statistics.mean","page":"Overloads","title":"Statistics.mean","text":"mean(itr)\n\nCompute the mean of all elements in a collection.\n\nnote: Note\nIf itr contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the mean of non-missing values.\n\nExamples\n\njulia> using Statistics\n\njulia> mean(1:20)\n10.5\n\njulia> mean([1, missing, 3])\nmissing\n\njulia> mean(skipmissing([1, missing, 3]))\n2.0\n\n\n\n\n\nmean(f::Function, itr)\n\nApply the function f to each element of collection itr and take the mean.\n\njulia> using Statistics\n\njulia> mean(√, [1, 2, 3])\n1.3820881233139908\n\njulia> mean([√1, √2, √3])\n1.3820881233139908\n\n\n\n\n\nmean(f::Function, A::AbstractArray; dims)\n\nApply the function f to each element of array A and take the mean over dimensions dims.\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\njulia> using Statistics\n\njulia> mean(√, [1, 2, 3])\n1.3820881233139908\n\njulia> mean([√1, √2, √3])\n1.3820881233139908\n\njulia> mean(√, [1 2 3; 4 5 6], dims=2)\n2×1 Matrix{Float64}:\n 1.3820881233139908\n 2.2285192400943226\n\n\n\n\n\nmean(A::AbstractArray; dims)\n\nCompute the mean of an array over the given dimensions.\n\ncompat: Julia 1.1\nmean for empty arrays requires at least Julia 1.1.\n\nExamples\n\njulia> using Statistics\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> mean(A, dims=1)\n1×2 Matrix{Float64}:\n 2.0  3.0\n\njulia> mean(A, dims=2)\n2×1 Matrix{Float64}:\n 1.5\n 3.5\n\n\n\n\n\n","category":"function"},{"location":"overloads/#Statistics.median","page":"Overloads","title":"Statistics.median","text":"median(itr)\n\nCompute the median of all elements in a collection. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.\n\nnote: Note\nIf itr contains NaN or missing values, the result is also NaN or missing (missing takes precedence if itr contains both). Use the skipmissing function to omit missing entries and compute the median of non-missing values.\n\nExamples\n\njulia> using Statistics\n\njulia> median([1, 2, 3])\n2.0\n\njulia> median([1, 2, 3, 4])\n2.5\n\njulia> median([1, 2, missing, 4])\nmissing\n\njulia> median(skipmissing([1, 2, missing, 4]))\n2.0\n\n\n\n\n\nmedian(A::AbstractArray; dims)\n\nCompute the median of an array along the given dimensions.\n\nExamples\n\njulia> using Statistics\n\njulia> median([1 2; 3 4], dims=1)\n1×2 Matrix{Float64}:\n 2.0  3.0\n\n\n\n\n\n","category":"function"},{"location":"overloads/#Statistics.quantile","page":"Overloads","title":"Statistics.quantile","text":"quantile(itr, p; sorted=false, alpha::Real=1.0, beta::Real=alpha)\n\nCompute the quantile(s) of a collection itr at a specified probability or vector or tuple of probabilities p on the interval [0,1]. The keyword argument sorted indicates whether itr can be assumed to be sorted.\n\nSamples quantile are defined by Q(p) = (1-γ)*x[j] + γ*x[j+1], where xj is the j-th order statistic, and γ is a function of j = floor(n*p + m), m = alpha + p*(1 - alpha - beta) and g = n*p + m - j.\n\nBy default (alpha = beta = 1), quantiles are computed via linear interpolation between the points ((k-1)/(n-1), v[k]), for k = 1:n where n = length(itr). This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R and NumPy default.\n\nThe keyword arguments alpha and beta correspond to the same parameters in Hyndman and Fan, setting them to different values allows to calculate quantiles with any of the methods 4-9 defined in this paper:\n\nDef. 4: alpha=0, beta=1\nDef. 5: alpha=0.5, beta=0.5\nDef. 6: alpha=0, beta=0 (Excel PERCENTILE.EXC, Python default, Stata altdef)\nDef. 7: alpha=1, beta=1 (Julia, R and NumPy default, Excel PERCENTILE and PERCENTILE.INC, Python 'inclusive')\nDef. 8: alpha=1/3, beta=1/3\nDef. 9: alpha=3/8, beta=3/8\n\nnote: Note\nAn ArgumentError is thrown if v contains NaN or missing values. Use the skipmissing function to omit missing entries and compute the quantiles of non-missing values.\n\nReferences\n\nHyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\", The American Statistician, Vol. 50, No. 4, pp. 361-365\nQuantile on Wikipedia details the different quantile definitions\n\nExamples\n\njulia> using Statistics\n\njulia> quantile(0:20, 0.5)\n10.0\n\njulia> quantile(0:20, [0.1, 0.5, 0.9])\n3-element Vector{Float64}:\n  2.0\n 10.0\n 18.000000000000004\n\njulia> quantile(skipmissing([1, 10, missing]), 0.5)\n5.5\n\n\n\n\n\n","category":"function"},{"location":"overloads/#Statistics.std","page":"Overloads","title":"Statistics.std","text":"std(itr; corrected::Bool=true, mean=nothing[, dims])\n\nCompute the sample standard deviation of collection itr.\n\nThe algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of itr is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1)). If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false with n the number of elements in itr.\n\nIf itr is an AbstractArray, dims can be provided to compute the standard deviation over dimensions, and means may contain means for each dimension of itr.\n\nA pre-computed mean may be provided. When dims is specified, mean must be an array with the same shape as mean(itr, dims=dims) (additional trailing singleton dimensions are allowed).\n\nnote: Note\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the standard deviation of non-missing values.\n\n\n\n\n\n","category":"function"},{"location":"basics/#Basic-information-on-layers","page":"Basic information on layers","title":"Basic information on layers","text":"","category":"section"},{"location":"basics/","page":"Basic information on layers","title":"Basic information on layers","text":"latitudes\nlongitudes\nboundingbox\ngrid\ncellsize","category":"page"},{"location":"#SimpleSDMLayers","page":"SimpleSDMLayers.jl","title":"SimpleSDMLayers","text":"","category":"section"},{"location":"","page":"SimpleSDMLayers.jl","title":"SimpleSDMLayers.jl","text":"The SimpleSDMLayers package offers types to represent raster data, as well as perform basic operations.","category":"page"},{"location":"#Supported-interfaces","page":"SimpleSDMLayers.jl","title":"Supported interfaces","text":"","category":"section"},{"location":"","page":"SimpleSDMLayers.jl","title":"SimpleSDMLayers.jl","text":"All SimpleSDMLayer subtypes support the iteration, indexing, broadcasting, and table interfaces.","category":"page"},{"location":"operations/#Operations-on-layers","page":"Operations on layers","title":"Operations on layers","text":"","category":"section"},{"location":"operations/","page":"Operations on layers","title":"Operations on layers","text":"clip\ncoarsen\nslidingwindow\nmask\nrescale!\nrescale\nmosaic\ntile\ntile!\nstitch","category":"page"},{"location":"operations/#SimpleSDMLayers.mask","page":"Operations on layers","title":"SimpleSDMLayers.mask","text":"mask(layer::SDMLayer, template::SDMLayer)\n\nReturns a copy of the first layer masked according to the second layer. See also mask!.\n\n\n\n\n\n","category":"function"},{"location":"operations/#SimpleSDMLayers.mosaic","page":"Operations on layers","title":"SimpleSDMLayers.mosaic","text":"mosaic(f, stack::Vector{<:SDMLayer})\n\nReturns a layer that is the application of f to the values at each cell in the array of layers given as the second argument.\n\n\n\n\n\n","category":"function"},{"location":"types/#List-of-types","page":"Layer data representation","title":"List of types","text":"","category":"section"},{"location":"types/","page":"Layer data representation","title":"Layer data representation","text":"SimpleSDMLayer\nSimpleSDMResponse\nSimpleSDMPredictor","category":"page"},{"location":"types/","page":"Layer data representation","title":"Layer data representation","text":"RasterCell","category":"page"}]
}
