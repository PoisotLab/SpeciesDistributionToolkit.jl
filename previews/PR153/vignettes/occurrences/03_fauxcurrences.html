<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generation of fauxcurrences · Species Distribution Toolkit</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../index.html">Species Distribution Toolkit</a></span></div><form class="docs-search" action="../../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../index.html">Index</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Working with layers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../layers/01_consensus_landcover_map.html">Creating a landcover consensus map</a></li><li><a class="tocitem" href="../layers/02_layers_arithmetic.html">Layer arithmetic</a></li><li><a class="tocitem" href="../layers/03_working_with_climate_data.html">Working with climate data</a></li><li><a class="tocitem" href="../layers/04_creating_masks.html">Creating masks of layers</a></li><li><a class="tocitem" href="../layers/05_tiling.html">Splitting layers in tiles</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Working with occurrences</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="01_getting_data_from_gbif.html">Getting data from GBIF</a></li><li><a class="tocitem" href="02_occurrences_and_layers.html">Occurrences and layers</a></li><li class="is-active"><a class="tocitem" href="03_fauxcurrences.html">Generation of fauxcurrences</a><ul class="internal"><li><a class="tocitem" href="#Why?"><span>Why?</span></a></li><li><a class="tocitem" href="#Overview-of-methods"><span>Overview of methods</span></a></li><li><a class="tocitem" href="#Anatomy-of-a-Fauxcurrences-run"><span>Anatomy of a <code>Fauxcurrences</code>  run</span></a></li><li><a class="tocitem" href="#Suspected-and-known-changes-to-the-original-package"><span>Suspected and known changes to the original package</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Integration examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../integration/01_statistics_on_layers.html">Statistics on layers</a></li><li><a class="tocitem" href="../integration/02_pseudo_absences.html">Generating background points</a></li></ul></li></ul></li><li><span class="tocitem">List of datasets</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">CHELSA1</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../datasets/CHELSA1/AverageTemperature.html">AverageTemperature</a></li><li><a class="tocitem" href="../../datasets/CHELSA1/BioClim.html">BioClim</a></li><li><a class="tocitem" href="../../datasets/CHELSA1/MaximumTemperature.html">MaximumTemperature</a></li><li><a class="tocitem" href="../../datasets/CHELSA1/MinimumTemperature.html">MinimumTemperature</a></li><li><a class="tocitem" href="../../datasets/CHELSA1/Precipitation.html">Precipitation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">CHELSA2</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../datasets/CHELSA2/AverageTemperature.html">AverageTemperature</a></li><li><a class="tocitem" href="../../datasets/CHELSA2/BioClim.html">BioClim</a></li><li><a class="tocitem" href="../../datasets/CHELSA2/MaximumTemperature.html">MaximumTemperature</a></li><li><a class="tocitem" href="../../datasets/CHELSA2/MinimumTemperature.html">MinimumTemperature</a></li><li><a class="tocitem" href="../../datasets/CHELSA2/Precipitation.html">Precipitation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">EarthEnv</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../datasets/EarthEnv/HabitatHeterogeneity.html">HabitatHeterogeneity</a></li><li><a class="tocitem" href="../../datasets/EarthEnv/LandCover.html">LandCover</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">WorldClim2</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../datasets/WorldClim2/AverageTemperature.html">AverageTemperature</a></li><li><a class="tocitem" href="../../datasets/WorldClim2/BioClim.html">BioClim</a></li><li><a class="tocitem" href="../../datasets/WorldClim2/Elevation.html">Elevation</a></li><li><a class="tocitem" href="../../datasets/WorldClim2/MaximumTemperature.html">MaximumTemperature</a></li><li><a class="tocitem" href="../../datasets/WorldClim2/MinimumTemperature.html">MinimumTemperature</a></li><li><a class="tocitem" href="../../datasets/WorldClim2/Precipitation.html">Precipitation</a></li><li><a class="tocitem" href="../../datasets/WorldClim2/SolarRadiation.html">SolarRadiation</a></li><li><a class="tocitem" href="../../datasets/WorldClim2/WaterVaporPressure.html">WaterVaporPressure</a></li><li><a class="tocitem" href="../../datasets/WorldClim2/WindSpeed.html">WindSpeed</a></li></ul></li></ul></li><li><span class="tocitem">GBIF.jl</span><ul><li><a class="tocitem" href="../../GBIF/index.html">GBIF.jl</a></li><li><a class="tocitem" href="../../GBIF/types.html">GBIF data representation</a></li><li><a class="tocitem" href="../../GBIF/data.html">GBIF data retrieval</a></li></ul></li><li><span class="tocitem">SimpleSDMDatasets.jl</span><ul><li><a class="tocitem" href="../../SimpleSDMDatasets/index.html">SimpleSDMDatasets.jl</a></li><li><a class="tocitem" href="../../SimpleSDMDatasets/dev/types.html">Data representation</a></li><li><a class="tocitem" href="../../SimpleSDMDatasets/dev/interface.html">Data retrieval interface</a></li><li><a class="tocitem" href="../../SimpleSDMDatasets/dev/internals.html">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Vignettes</a></li><li><a class="is-disabled">Working with occurrences</a></li><li class="is-active"><a href="03_fauxcurrences.html">Generation of fauxcurrences</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="03_fauxcurrences.html">Generation of fauxcurrences</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PoisotLab/SpeciesDistributionToolkit.jl/blob/main/docs/src/vignettes/occurrences/03_fauxcurrences.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Generation-of-fauxcurrences"><a class="docs-heading-anchor" href="#Generation-of-fauxcurrences">Generation of fauxcurrences</a><a id="Generation-of-fauxcurrences-1"></a><a class="docs-heading-anchor-permalink" href="#Generation-of-fauxcurrences" title="Permalink"></a></h1><p>The <code>Fauxcurrences.jl</code> package is a <em>clean-room</em>, <em>feature-equivalent</em> re-write in Julia of most of the functionalities of the [<code>fauxcurrence</code> package for R][paper]. The original code is licensed under the GPL, and this package is licensed under the MIT. For this reason, the original code, and any document distributed with it, has not been consulted during the implementation; the work is entirely based on the published article. As detailed in the following sections, the two packages do not have <em>feature parity</em>, but there is an overlap in the most significant functions.</p><p>[paper]: https://onlinelibrary.wiley.com/doi/full/10.1111/ecog.05880</p><p>The citation for the original <code>fauxcurrence</code> paper is</p><blockquote><p>Osborne, O. G., Fell, H. G., Atkins, H., van Tol, J., Phillips, D., Herrera‐Alsina, L., Mynard, P., Bocedi, G., Gubry‐Rangin, C., Lancaster, L. T., Creer, S., Nangoy, M., Fahri, F., Lupiyaningdyah, P., Sudiana, I. M., Juliandi, B., Travis, J. M. J., Papadopulos, A. S. T., &amp; Algar, A. C. (2022). Fauxcurrence: Simulating multi‐species occurrences for null models in species distribution modelling and biogeography. Ecography. https://doi.org/10.1111/ecog.05880</p></blockquote><h2 id="Why?"><a class="docs-heading-anchor" href="#Why?">Why?</a><a id="Why?-1"></a><a class="docs-heading-anchor-permalink" href="#Why?" title="Permalink"></a></h2><p>Interoperability: this package uses <code>SimpleSDMLayers</code>, <code>Distances</code>, and <code>GBIF</code> as backends, making it fit very snuggly with the rest of the <code>SpeciesDistributionToolkit</code> ecosystem, and working towards integration of tools to build SDMs at scale.</p><p>Expandability: the package is built on modular functions, to ensure that custom workflows can be built, while maintaining a general interface.</p><p>Performance: by relying on pre-allocated matrices, the operations are fairly fast. Whenever a point changes, only the matrices that are impacted are updated, which results in notable improvements for more taxa.</p><p>Licensing: the package uses the more permissive MIT license, imposing fewer constraints on contributors.</p><h2 id="Overview-of-methods"><a class="docs-heading-anchor" href="#Overview-of-methods">Overview of methods</a><a id="Overview-of-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-methods" title="Permalink"></a></h2><p>Note that <em>none</em> of the methods are exported, so they need to be called with <code>Fauxcurrences.method_name</code>. These methods are the ones that users will need to call to set-up a whole run of the pipeline.</p><table><tr><th style="text-align: right">method</th><th style="text-align: right">description</th></tr><tr><td style="text-align: right"><code>get_valid_coordinates</code></td><td style="text-align: right">transforms GBIF observations to a matrix of coordinates</td></tr><tr><td style="text-align: right"><code>preallocate_distance_matrices</code></td><td style="text-align: right">prepares the matrices for the intra/inter-specific distances</td></tr><tr><td style="text-align: right"><code>measure_intraspecific_distances!</code></td><td style="text-align: right">updates the intra-specific distances</td></tr><tr><td style="text-align: right"><code>measure_interspecific_distances!</code></td><td style="text-align: right">updates the inter-specific distances</td></tr><tr><td style="text-align: right"><code>preallocate_simulated_points</code></td><td style="text-align: right">prepare the matrix for the coordinates of simulated points</td></tr><tr><td style="text-align: right"><code>bootstrap!</code></td><td style="text-align: right">generates the initial proposition for the null</td></tr><tr><td style="text-align: right"><code>score_distributions</code></td><td style="text-align: right">measures the distribution distance</td></tr></table><h2 id="Anatomy-of-a-Fauxcurrences-run"><a class="docs-heading-anchor" href="#Anatomy-of-a-Fauxcurrences-run">Anatomy of a <code>Fauxcurrences</code>  run</a><a id="Anatomy-of-a-Fauxcurrences-run-1"></a><a class="docs-heading-anchor-permalink" href="#Anatomy-of-a-Fauxcurrences-run" title="Permalink"></a></h2><p><strong>Step 0</strong>. Prepare the run - the minimal ingredients are a set of coordinates (for example using the <code>GBIF.jl</code> package), and a layer (one of the <code>SimpleSDMLayer</code> types, predictor or response does not matter).</p><pre><code class="language-julia hljs">using SpeciesDistributionToolkit</code></pre><pre><code class="language-julia hljs">import Random
Random.seed!(616525434012345)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Random.TaskLocalRNG()</code></pre><h3 id="Prepare-the-occurence-data"><a class="docs-heading-anchor" href="#Prepare-the-occurence-data">Prepare the occurence data</a><a id="Prepare-the-occurence-data-1"></a><a class="docs-heading-anchor-permalink" href="#Prepare-the-occurence-data" title="Permalink"></a></h3><p>Get the observation data in the correct format, which is an array of matrices with two rows (longitude, latitude) and one column for observed occurrence. This is usually an array of GBIF observations, but all that matters is that this is a matrix with longitudes in the first row, and latitudes in the second row. The matrix <em>has</em> to be column-major, with observations as columns. To make sure that we cover a reasonable spatial extent, we will look at the rather small area in space (part of the Gaspésie region):</p><pre><code class="language-julia hljs">bbox = (bottom = 43.285203, left = -68.631592, top = 47.487513, right = -59.458008)
layer = SimpleSDMPredictor(RasterData(CHELSA1, BioClim); layer = 1, bbox...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SDM predictor → 505×1102 grid with 255927 Int16-valued cells
  Latitudes	43.28319391135002 ⇢ 47.49152722785002
  Longitudes	-68.63347266765 ⇢ -59.45013937105001</code></pre><p>We will pick two species (a skunk, and <em>Iris versicolor</em>):</p><pre><code class="language-julia hljs">taxa =
    taxon.([
        &quot;Mephitis mephitis&quot;,
        &quot;Iris versicolor&quot;,
    ])

observations = [
    occurrences(t,
        &quot;hasCoordinate&quot; =&gt; &quot;true&quot;,
        &quot;occurrenceStatus&quot; =&gt; &quot;PRESENT&quot;,
        &quot;decimalLatitude&quot; =&gt; extrema(latitudes(layer)),
        &quot;decimalLongitude&quot; =&gt; extrema(longitudes(layer)),
        &quot;limit&quot; =&gt; 150) for t in taxa
]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{GBIFRecords}:
 GBIF records: downloaded 150 out of 158

 GBIF records: downloaded 150 out of 1105
</code></pre><p>The last step is to turn these occurrences into a matrix of latitudes and longitudes:</p><pre><code class="language-julia hljs">obs = [Fauxcurrences.get_valid_coordinates(o, layer) for o in observations]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Matrix{Float64}}:
 [-62.615855 -64.845592 … -65.45 -67.655965; 46.319072 45.048395 … 47.4167 46.905216]
 [-64.63611 -63.30689 … -65.730192 -68.31802; 45.063603 45.566879 … 45.483058 44.225524]</code></pre><h3 id="Parameters-for-the-run"><a class="docs-heading-anchor" href="#Parameters-for-the-run">Parameters for the run</a><a id="Parameters-for-the-run-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters-for-the-run" title="Permalink"></a></h3><p>We need to decide on the number of points (pseudo-occurrences) to generate, and the weight matrix. The number of points to generate is, by default, the number of observations in the original dataset, but this can be changed to generate balanced samples. Here, we will pick 80 as a target number of occurrences:</p><pre><code class="language-julia hljs">points_to_generate = fill(80, length(obs))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Int64}:
 80
 80</code></pre><p>The weight matrix is used to determine whether intra or inter-specific distances are more important in the distribution score. For example, this will set up a scoring scheme where intra-specific distances count for 75% of the total. The only constraint is that the matrix <code>W</code> <em>must</em> sum to 1, which is enforced by the code internally:</p><pre><code class="language-julia hljs">W = Fauxcurrences.weighted_components(length(obs), 0.75)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 0.375  0.25
 0.0    0.375</code></pre><h3 id="Pre-allocate-the-objects"><a class="docs-heading-anchor" href="#Pre-allocate-the-objects">Pre-allocate the objects</a><a id="Pre-allocate-the-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-allocate-the-objects" title="Permalink"></a></h3><p>This is an important part of the run, as <code>Fauxcurrences</code> is built to <em>not</em> allocate more memory than needed. As such, these objects are going to be re-written many, many times. The upside is that, if this steps fits in your memory, the entire workflow will also fit in your memory.</p><pre><code class="language-julia hljs">obs_intra, obs_inter, sim_intra, sim_inter =
    Fauxcurrences.preallocate_distance_matrices(obs; samples = points_to_generate);</code></pre><p>The entire workflow is designed to use multiple species (as most relevant questions will require multiple species). Using a single-species approach only required to pass <code>[obs]</code> as opposed to <code>obs</code>.</p><h3 id="Measure-the-intra-and-inter-specific-distances"><a class="docs-heading-anchor" href="#Measure-the-intra-and-inter-specific-distances">Measure the intra and inter-specific distances</a><a id="Measure-the-intra-and-inter-specific-distances-1"></a><a class="docs-heading-anchor-permalink" href="#Measure-the-intra-and-inter-specific-distances" title="Permalink"></a></h3><p>This is an important step as <em>all generated points</em> will maintain the upper bounds of these distances matrices, <em>even if the inter-specific distance are weightless</em>.</p><pre><code class="language-julia hljs">Fauxcurrences.measure_intraspecific_distances!(obs_intra, obs);
Fauxcurrences.measure_interspecific_distances!(obs_inter, obs);</code></pre><h3 id="Bootstrap-the-initial-set-of-points"><a class="docs-heading-anchor" href="#Bootstrap-the-initial-set-of-points">Bootstrap the initial set of points</a><a id="Bootstrap-the-initial-set-of-points-1"></a><a class="docs-heading-anchor-permalink" href="#Bootstrap-the-initial-set-of-points" title="Permalink"></a></h3><p>This is a two-step process, involving first the pre-allocation of coordinate matrices, and second the population of these matrices using random points.</p><pre><code class="language-julia hljs">sim = Fauxcurrences.preallocate_simulated_points(obs; samples = points_to_generate);</code></pre><p>The actual bootstrapping can be a little longer:</p><pre><code class="language-julia hljs">Fauxcurrences.bootstrap!(sim, layer, obs, obs_intra, obs_inter, sim_intra, sim_inter);</code></pre><h3 id="Bin-the-distance-matrices"><a class="docs-heading-anchor" href="#Bin-the-distance-matrices">Bin the distance matrices</a><a id="Bin-the-distance-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Bin-the-distance-matrices" title="Permalink"></a></h3><p>This is to prepare the scoring of the initial solution. Note that the package will <em>never</em> allow points in the simulated occurrences to create a distance matrix where the maximum distance is larger than the maximum distance in the empirical matrix.</p><pre><code class="language-julia hljs">bin_intra = [
    Fauxcurrences._bin_distribution(obs_intra[i], maximum(obs_intra[i])) for
    i in axes(obs_intra, 1)
];
bin_inter = [
    Fauxcurrences._bin_distribution(obs_inter[i], maximum(obs_inter[i])) for
    i in axes(obs_inter, 1)
];
bin_s_intra = [
    Fauxcurrences._bin_distribution(sim_intra[i], maximum(obs_intra[i])) for
    i in axes(obs_intra, 1)
];
bin_s_inter = [
    Fauxcurrences._bin_distribution(sim_inter[i], maximum(obs_inter[i])) for
    i in axes(obs_inter, 1)
];</code></pre><p>This version of the <code>_bin_distribution</code> function is allocating an array for the bins, but the internal function is over-writing it, to avoid unwanted allocations.</p><h3 id="Measure-the-initial-divergence"><a class="docs-heading-anchor" href="#Measure-the-initial-divergence">Measure the initial divergence</a><a id="Measure-the-initial-divergence-1"></a><a class="docs-heading-anchor-permalink" href="#Measure-the-initial-divergence" title="Permalink"></a></h3><p>This will be the starting point between the observed and simulated distributions, and the score that we want to improve. Note that it accounts for the weights in the matrix. This step will return a vector, the sum of which is the total divergence between the matrices.</p><pre><code class="language-julia hljs">D = Fauxcurrences.score_distributions(W, bin_intra, bin_s_intra, bin_inter, bin_s_inter)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 0.04326019576646957
 0.021596614867238195
 0.08683576602704066</code></pre><h3 id="Setup-the-actual-run"><a class="docs-heading-anchor" href="#Setup-the-actual-run">Setup the actual run</a><a id="Setup-the-actual-run-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-the-actual-run" title="Permalink"></a></h3><p>This step has infinitely many variations, as <code>Fauxcurrences</code> only offers a method to perform <em>a single step forward</em>. In most cases, using <em>e.g.</em> <code>ProgressMeter</code> will be a good way to track the progress of the run, and to allow, for example, to stop it when a collection of criteria (absolute/relative divergence, globally, on average, or per-species) are met. For the sake of simplicity, we return the sum of all divergences, measures for 500000 timesteps.</p><pre><code class="language-julia hljs">progress = zeros(Float64, 500_000)
progress[1] = sum(D)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.15169257666074842</code></pre><h3 id="Run!"><a class="docs-heading-anchor" href="#Run!">Run!</a><a id="Run!-1"></a><a class="docs-heading-anchor-permalink" href="#Run!" title="Permalink"></a></h3><p>The <code>step!</code> function takes most of what we have allocated so far, which is a lot, but allows considerable performance gains. The last argument to <code>step!</code> is the current divergence, and the return value of <code>step!</code> (in addition to modifying the simulated points) is the new divergence.</p><p>Before running the actual loop, it is a good idea to time a handful of steps? Why a handful? Because Julia do be compiling, and because depending on the structure of your points, the problem might be more or less difficult to solve. In practice, using <code>ProgressMeter</code> will make the timing of the whole process a lot more informative. In this simple version, we rely on a manually created progress report. Note that we stop the process when we have done at least 10⁴ steps, with no improvement over the last 10³.</p><pre><code class="language-julia hljs">for i in axes(progress, 1)[2:end]
    progress[i] = Fauxcurrences.step!(
        sim,
        layer,
        W,
        obs_intra,
        obs_inter,
        sim_intra,
        sim_inter,
        bin_intra,
        bin_inter,
        bin_s_intra,
        bin_s_inter,
        progress[i - 1],
    )
    if i &gt; 10_000
        if abs(progress[i] - progress[i - 1000]) &lt;= 1e-3
            break
        end
    end
    if iszero(i % 20_000)
        println(
            &quot;[$(lpad(round(Int64, 100*(i/length(progress))), 3))%]\tJS-divergence: $(round(progress[i]; digits=3))&quot;,
        )
    end
end</code></pre><p>The call to <code>step!</code> is... lengthy. The reason for this is very simple: <code>step!</code> will update as much information as it can <em>in place</em> when a change is made. This means that there are no objects created (only changed). The downside is that the function needs to be given a lot of information.</p><p>Depending on the number of species (and the structure of the weight matrix), this step will be taking a little while. This is because, assuming we want <em>n</em> points for <em>r</em> species, each step has a complexity on the order of <em>rn²</em>, which isn&#39;t terribly good.</p><h3 id="Congratulations,-your-run-is-done!"><a class="docs-heading-anchor" href="#Congratulations,-your-run-is-done!">Congratulations, your run is done!</a><a id="Congratulations,-your-run-is-done!-1"></a><a class="docs-heading-anchor-permalink" href="#Congratulations,-your-run-is-done!" title="Permalink"></a></h3><p>Here, it would make sense to look at the total improvement (or to plot the timeseries of the improvement):</p><pre><code class="language-julia hljs">println(
    &quot;Improvement: $(round(progress[begin]/progress[findlast(x -&gt; x&gt;0, progress)]; digits=2)) ×&quot;,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Improvement: 5.36 ×</code></pre><p>Note that for a small number of iterations (like we used here), this improvement is unlikely to be very large; note also that the returns (in terms of improvement over time) are very much diminishing. The good news is that re-starting the process is as easy as running the loop with calls to <code>step!</code> again, as the package has modified the matrices, and is ready to restart at any time. This is useful for checkpointing.</p><p>You can also look at the per-matrix score, out of all the distance bins (set as a package-wide variable, <code>Fauxcurrences._number_of_bins</code>, which you are encouraged to tweak) – under a <em>good</em> fit, the lines in <code>bin_intra</code> and <code>bin_s_intra</code> would overlap (same with <code>..._inter</code>).</p><h2 id="Suspected-and-known-changes-to-the-original-package"><a class="docs-heading-anchor" href="#Suspected-and-known-changes-to-the-original-package">Suspected and known changes to the original package</a><a id="Suspected-and-known-changes-to-the-original-package-1"></a><a class="docs-heading-anchor-permalink" href="#Suspected-and-known-changes-to-the-original-package" title="Permalink"></a></h2><p>The changes are classified by whether or not we <strong>KNOW</strong> or <strong>SUSPECT</strong> a change, and further by whether the change is a <strong>difference</strong> (the two packages do things differently), a <strong>removal</strong> (features from <code>fauxcurrence</code> have not been ported), or an <strong>addition</strong> (<code>Fauxcurrences.jl</code> has unique features). Note that because the maintainers of the two packages <em>do</em> chat, this list may not be entirely up to date, and there has been exchange of ideas and features already.</p><p><strong>KNOWN/difference</strong> The distance between distribution is measured using the square root of the ranged Jensen-Shannon divergence (the original package uses the Kullback-Leibler divergence) - this measure gives a value in 0-1 <em>and</em> is a true metric. The JS distance is symmetrical for any two distributions, but more importantly, never returns an infinite value when one density is 0 and the other is not. For sparse datasets and/or clumped occurrences, this means that JS will return a value that can still be compared by the optimizer. Note also that for a JS distance of x, the equivalent KL divergence would be of the order of x². Using JS distance has the notable advantage of allowing to use an upper-triangular matrix for weights, which speeds up calculations significantly. Future releases of the package might allow complete matrices, but for the moment, these seem to require more guesses about the parameters than we are comfortable with.</p><p><strong>KNOWN/addition</strong> The number of points to simulate can be fixed <em>per species</em>, which is important because we may want to benchmark algorithms under the unrealistic assumption that the sampling effort is the same. It also allows users to generate smaller samples of simulated points, which is useful if some species have a lot of occurrences.</p><p><strong>KNOWN/removal</strong> The bootstrap phase (generation of the initial null) picks distances from the distance matrix, rather than performing an estimation of the underlying distribution. This is mostly because the points will be refined anyways, so the faster solution was selected, and because performing a kernel approximation sometimes smoothed out ecologically relevant structure in the data (notably archipelagos, or grid-based sampling).</p><p><strong>SUSPECTED/difference</strong> The constraints on simulated points are as follow: the intra-specific distance cannot be larger than the observed intra-specific distance, and the inter-specific distance cannot be larger than the observed pairwise inter-specific distance. This is motivated by two reasons. First, this makes the binning of the distributions a lot more stable, as the upport bound of the distribution remains the same. Second, this ensures that the optimizer does not &quot;cheat&quot; by over-expanding the simulated points.</p><p><strong>SUSPECTED/difference</strong> During optimization, the <em>only</em> criteria that is checked is that the average of all divergences (intra-specific and pairwise inter-specific) must decrease; this can result in <em>increases</em> of the distance for one or more of the component distributions. There is no indication in the original manuscript of what constitutes an acceptable move, and the clean-room re-implementation means that the code was not consulted. This is scheduled to be a change in future versions of the package, likely using a <code>strict</code> keyword to decide whether all divergences need to decrease for the move to be considered valid.</p><p><strong>KNOWN/removal</strong> <code>Fauxcurrences.jl</code> does not offer non-pairwsie inter-specific distances. This is a direct consequence of the next point, which is one of the most significant additions to the package.</p><p><strong>KNOWN/addition</strong> <code>Fauxcurrences.jl</code> offers the ability to weigh the different matrices (intra v. inter). In the default configuration, all <em>matrices</em> have the same weight. An alternative calibration scheme is to give an equivalent weight to the sum of the <em>n</em> intra-specific matrices, and of the <em>n(n-1)/2</em> inter-specific matrices. Additional calibrations can reflect other biological constraints. This addition is important because in the case of multiple species, the pairwise inter-specific distances can rapidly dominate the overall score. The ability to set a weight matrix can lead to, for example, starting the null model with only the intra-specific matrices, and then optimizing the inter-specific matrices.</p><p><strong>KNOWN/difference</strong> <code>Faucurrences.jl</code> does not generate distribution of <em>raster cells</em>, and is focused on <em>observations</em>. This has been motivated by our use-cases where rasters can have different spatial resolutions. Generating occurrences is a little bit more computationally expensive, but the memory footprint has been optimized and the code is rapid enough that downscaling the data prior to generation was not identified as a requirement.</p><p><strong>KNOWN/difference</strong> By default, <code>Fauxcurrences.jl</code> uses the Haversine distance for both the evaluation of distance matrices and the generation of new points. This decision was taken because (i) the Haversine distance is probably a good enough approximation given the possible measurement error, sampling biases, and raster resolution, and (ii) the first geodetic problem can be solved in a very computationally efficient way for this distance, speeding up the generation of new points significantly. Do note that generated points are <em>guaranteed</em> to lay on a valued cell of the layer given as a template.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="02_occurrences_and_layers.html">« Occurrences and layers</a><a class="docs-footer-nextpage" href="../integration/01_statistics_on_layers.html">Statistics on layers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 21 February 2023 21:30">Tuesday 21 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
