var documenterSearchIndex = {"docs":
[{"location":"#SimpleSDMLayers","page":"SimpleSDMLayers","title":"SimpleSDMLayers","text":"","category":"section"},{"location":"#SimpleSDMLayers._centroid_rotation-Tuple{Any, Any}","page":"SimpleSDMLayers","title":"SimpleSDMLayers._centroid_rotation","text":"_centroid_rotation(xy, degrees)\n\nRotates a group of points around their centroid by an angle given in degrees\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers._read_geotiff-Tuple{AbstractString}","page":"SimpleSDMLayers","title":"SimpleSDMLayers._read_geotiff","text":"geotiff(file; bandnumber::Integer=1, left=nothing, right=nothing, bottom=nothing, top=nothing, driver)\n\nThe geotiff function reads a geotiff file, and returns it as a matrix of the correct type. The optional arguments left, right, bottom, and left are defining the bounding box to read from the file. This is particularly useful if you want to get a small subset from large files.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers._rotation_x-NTuple{4, Any}","page":"SimpleSDMLayers","title":"SimpleSDMLayers._rotation_x","text":"_rotation_x(x, y, z, θ)\n\nRotation along the axis ending at the Bay of Guinea\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers._rotation_y-NTuple{4, Any}","page":"SimpleSDMLayers","title":"SimpleSDMLayers._rotation_y","text":"_rotation_y(x, y, z, θ)\n\nRotation along the axis ending at the Bay of Bengal\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers._rotation_z-NTuple{4, Any}","page":"SimpleSDMLayers","title":"SimpleSDMLayers._rotation_z","text":"_rotation_z(x, y, z, θ)\n\nRotation around the polar axis – latitude is constant but longitude changes\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers._spherical_rotation","page":"SimpleSDMLayers","title":"SimpleSDMLayers._spherical_rotation","text":"_spherical_rotation(xy, degrees, axis=1)\n\nRotation of the Earth alongside three axes, by a given angle in degrees.\n\nAxis 1 - x rotation - rotates around the axis ending in the Bay of Guinea\n\nAxis 2 - y rotation - rotates around the axis ending in the Gulf of Bengal\n\nAxis 3 - z rotation - rotates around the axis ending at the North Pole\n\n\n\n\n\n","category":"function"},{"location":"#SimpleSDMLayers._write_geotiff-Union{Tuple{T}, Tuple{AbstractString, Array{SDMLayer{T}, 1}}} where T<:Number","page":"SimpleSDMLayers","title":"SimpleSDMLayers._write_geotiff","text":"geotiff(file::AbstractString, layers::Vector{SDMLayer{T}}; nodata::T=convert(T, -9999)) where {T <: Number}\n\nStores a series of layers in a file, where every layer in a band. See geotiff for other options.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.burnin!-Union{Tuple{T}, Tuple{SDMLayer{T}, Vector{T}}} where T","page":"SimpleSDMLayers","title":"SimpleSDMLayers.burnin!","text":"burnin!(L::SDMLayer{T}, v::Vector{T})\n\nReplaces the values of L by the values in the vector v.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.burnin-Union{Tuple{T}, Tuple{SDMLayer, Vector{T}}} where T","page":"SimpleSDMLayers","title":"SimpleSDMLayers.burnin","text":"burnin(L::SDMLayer, v::Vector{T}) where {T}\n\nWrites the value of v in a layer similar to L, and returns it. It is ASSUMED (but essentially impossible to check) that the values of v are presented in the correct order. This uses burnin! internally.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.cellarea-Tuple{T} where T<:SDMLayer","page":"SimpleSDMLayers","title":"SimpleSDMLayers.cellarea","text":"cellarea(layer::T; R = 6371.0)\n\nReturns the area of each cell in km², assuming a radius of the Earth or R (in km). This is only returned for layers in WGS84, which can be forced with interpolate.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.coarsen","page":"SimpleSDMLayers","title":"SimpleSDMLayers.coarsen","text":"coarsen(f, L::SDMLayer, mask=(2, 2))\n\nCoarsens a layer by collecting a sub-grid of size mask, and applying the function f to all non-empty cells within this mask. The core constraint is that f must take a vector and return a single element (and the size of the mask must be compatible with the size of the layer).\n\n\n\n\n\n","category":"function"},{"location":"#SimpleSDMLayers.findrotation-Tuple{SDMLayer, SDMLayer}","page":"SimpleSDMLayers","title":"SimpleSDMLayers.findrotation","text":"findrotation(L, P; longitudes=-10:0.1:10, latitudes=-10:0.1:10, rotations=-10:0.1:10, maxiter=10_000)\n\nFind a possible rotation for the shiftandrotate function, by attempting to move a target layer L until all of the shifted and rotated coordinates are valid coordinates in the layer P. The range of angles to explore is given as keywords, and the function accepts a maxiter argument after which, if no rotation is found, it returns nothing.\n\nThe output of this method is either nothing (no valid rotation found), or a rotator function (see the documentation for rotator).\n\nNote that it is almost always a valid strategy to look for shifts and rotations on a raster at a coarser resolution.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.interpolate-Tuple{SDMLayer, SDMLayer}","page":"SimpleSDMLayers","title":"SimpleSDMLayers.interpolate","text":"interpolate(layer::SDMLayer, destination::SDMLayer)\n\nInterpolates a layer target so that it uses the same grid, crs, etc as destination.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.interpolate-Tuple{SDMLayer}","page":"SimpleSDMLayers","title":"SimpleSDMLayers.interpolate","text":"interpolate(layer::SDMLayer; dest=\"+proj=natearth2\", newsize=nothing)\n\nReturns an interpolated version of the later under the new destination CRS (natearth2 by default), and with optionally a new size of newsize.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.localrotation-Tuple{Any}","page":"SimpleSDMLayers","title":"SimpleSDMLayers.localrotation","text":"localrotation(angle)\n\nReturns a function to create a rotation of coordinates around their centroids.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.lonlat-Tuple{SDMLayer}","page":"SimpleSDMLayers","title":"SimpleSDMLayers.lonlat","text":"lonlat(L::SDMLayer)\n\nReturns a vector of longitudes and latitudes for a layer. This will handle the CRS of the layer correctly. Note that only the positions that are valued (i.e. using keys) will be returned. The values are given in an order suitable for use in burnin!.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.mask!-Tuple{SDMLayer, SDMLayer}","page":"SimpleSDMLayers","title":"SimpleSDMLayers.mask!","text":"mask!(layer::SDMLayer, template::SDMLayer)\n\nUpdates the positions in the first layer to be those that have a value in the second layer.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.mask-Tuple{SDMLayer, SDMLayer}","page":"SimpleSDMLayers","title":"SimpleSDMLayers.mask","text":"mask(layer::SDMLayer, template::SDMLayer)\n\nReturns a copy of the first layer masked according to the second layer. See also mask!.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.mosaic-Tuple{Any, Vector{<:SDMLayer}}","page":"SimpleSDMLayers","title":"SimpleSDMLayers.mosaic","text":"mosaic(f, stack::Vector{<:SDMLayer})\n\nReturns a layer that is the application of f to the values at each cell in the array of layers given as the second argument.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.nodata!-Union{Tuple{T}, Tuple{SDMLayer, T}} where T<:Function","page":"SimpleSDMLayers","title":"SimpleSDMLayers.nodata!","text":"nodata!(layer::SDMLayer{T}, f)\n\nRemoves the data matching a function\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.nodata!-Union{Tuple{T}, Tuple{SDMLayer{T}, T}} where T","page":"SimpleSDMLayers","title":"SimpleSDMLayers.nodata!","text":"nodata!(layer::SDMLayer{T}, nodata::T) where {T}\n\nChanges the value of the layer representing no data. This modifies the layer passed as its first argument.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.nodata-Tuple{SDMLayer, Vararg{Any}}","page":"SimpleSDMLayers","title":"SimpleSDMLayers.nodata","text":"nodata(layer::SDMLayer, args...)\n\nMakes a copy and calls nodata! on it\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.quantiletransfer!-Union{Tuple{T}, Tuple{SDMLayer{T}, SDMLayer{T}}} where T<:Real","page":"SimpleSDMLayers","title":"SimpleSDMLayers.quantiletransfer!","text":"quantiletransfer!(target::SDMLayer{T}, reference::SDMLayer) where {T <: Real}\n\nReplaces the values in the target layer so that they follow the distribution of the values in the reference layer. This works by (i) identifying the quantile of each cell in the target layer, then (ii) replacing this with the value for the same quantile in the reference layer.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.quantiletransfer-Union{Tuple{T}, Tuple{SDMLayer{T}, SDMLayer{T}}} where T<:Real","page":"SimpleSDMLayers","title":"SimpleSDMLayers.quantiletransfer","text":"quantiletransfer(target, reference)\n\nNon-mutating version of quantiletransfer!\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.reclassify-Tuple{SDMLayer, Vararg{Pair}}","page":"SimpleSDMLayers","title":"SimpleSDMLayers.reclassify","text":"reclassify(L::SDMLayer, rules::Pair...)\n\nReturns a layer where the cells are updated as a function of rules, given as (function) => value, where the function must return a Bool value. For example, reclassify(layer, (x -> abs(x)<=1)=>true) will set a value of true to all cells with values in -1;1, and maks all other cells. You can use multiple rules, in which case they are applied sequentially (a later rule can overwrite an earlier one).\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.rotator-Union{Tuple{T}, Tuple{T, T, T}} where T<:Number","page":"SimpleSDMLayers","title":"SimpleSDMLayers.rotator","text":"rotator(longitude::T, latitude::T, rotation::T) where T <: Number\n\nReturns a function to transform a vector of lon,lat points according to three operations done in order:\n\n- a shift of the longitudes\n- a shift of the latitudes (the order of these two operations is actually irrelevant)\n- a local rotation around the centroid\n\nAll the angles are given in degrees. The output of this function is a function that takes a vector of coordinates to transform. The transformations do account for the curvature of the Earth. For this reason, rotations and changes in the latitudes will deform the points, but shift in the longitudes will not.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.shiftandrotate!-Tuple{SDMLayer, SDMLayer, Any}","page":"SimpleSDMLayers","title":"SimpleSDMLayers.shiftandrotate!","text":"shiftandrotate!(L::SDMLayer, P::SDMLayer, rotator)\n\nReturns the output of shifting and rotating the layer L on the layer P, according to a rotator function, obtained with for example findrotation. This function overwrites L.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.shiftandrotate-Tuple{SDMLayer, SDMLayer, Any}","page":"SimpleSDMLayers","title":"SimpleSDMLayers.shiftandrotate","text":"shiftandrotate(L::SDMLayer, P::SDMLayer, rotator)\n\nReturns the output of shifting and rotating the layer L on the layer P, according to a rotator function, obtained with for example findrotation. This function generates a copy of L.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.shiftlatitudes-Tuple{Any}","page":"SimpleSDMLayers","title":"SimpleSDMLayers.shiftlatitudes","text":"shiftlatitudes(angle)\n\nReturns a function to move coordinates up or down in latitudes by a given angle in degree. Note that this accounts for the curvature of the Earth, and therefore requires three distinct operations. First, the points are moved so that their centroid has a longitude of 0; then, the points are shifted in latitute by performing a rotation along the pitch axis by the desired angle; finally, the centroid of the points is brought back to its original longitude. For this reason, and because the rotation along the pitch axis accounts for the curvature of the Earth, this function will deform the shape, and specifically change the range of longitudes covered.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.shiftlongitudes-Tuple{Any}","page":"SimpleSDMLayers","title":"SimpleSDMLayers.shiftlongitudes","text":"shiftlongitudes(angle)\n\nShifts the longitudes of a group of points by performing a rotation alonside the yaw axis (going through the Nort pole). This preserves the latitudes of all points exactly and does not deform the shape.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleSDMLayers.tiles","page":"SimpleSDMLayers","title":"SimpleSDMLayers.tiles","text":"tiles(layer::SDMLayer, size::Tuple{Int64,Int64})\n\n\n\n\n\n","category":"function"},{"location":"#SimpleSDMLayers.SDMLayer","page":"SimpleSDMLayers","title":"SimpleSDMLayers.SDMLayer","text":"SDMLayer{T}\n\nDefines a layer of geospatial information.\n\nThe type has two data fields:\n\ngrid: a Matrix of type T\nindices: a BitMatrix to see which positions are valued\n\nEach row in the grid field represents a slice of the raster of equal northing, i.e. the information is laid out in the matrix as it would be represented on a map once displayed. Similarly, columns have the same easting.\n\nThe geospatial information is represented by three positional fields:\n\nx and y: two tuples, indicating the coordinates of the corners alongside the x and y dimensions (e.g. easting/northing) - the default values are (-180., 180.) and (-90., 90.), which represents the entire surface of the globe in WGS84\ncrs: any String representation of the CRS which can be handled by Proj.jl - the default is  \"+proj=longlat +datum=WGS84 +no_defs\", which represents a latitude/longitude coordinate system\n\n\n\n\n\n","category":"type"}]
}
