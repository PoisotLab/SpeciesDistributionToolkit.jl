# # Generating background points

# In this vignette, we will generate some background points (pseudo-absences)
# using the different algorithms present in the package. The pseudo-absences are
# generated through the `PseudoAbsences` component package.

using SpeciesDistributionToolkit
using CairoMakie
CairoMakie.activate!(; type = "png", px_per_unit = 2) #hide

# Pseudo-absence generation requires occurrences super-imposed on a layer, so we
# will collect a few occurrences:

records = OccurrencesInterface.__demodata()
landmass = getpolygon(PolygonData(OpenStreetMap, Places); place="Wyoming")
records = Occurrences(clip(records, landmass))
spatial_extent = SpeciesDistributionToolkit.boundingbox(landmass)

# We will get a single layer (elevation, but it's not important here):

dataprovider = RasterData(WorldClim2, Elevation)
layer = SDMLayer(dataprovider; resolution=10.0, spatial_extent...)

# Pseudo-absences generations always starts by masking a layer by the
# observations. The output of this command is a layer with Boolean values, where
# the cells in which at least one occurrence is reported are `true`.

presencelayer = mask(layer, presences)

# We can for example generate a buffer for pseudo-absences in a radius of 30km
# around each point. Note that the `WithinRadius` method uses *kilometers* and not
# minutes of arc, so that the actual area is the same regardless of the latitude
# of the points. Note that the speed of the operation depends on the number of
# cells with an observation (linearly), and of the radius and raster resolution
# (to a power of 2). Internally, the code uses a variety of tricks to only look at
# cells that are susceptible to being pseudo-absences, but the `WithinRadius`
# method in particular can take a bit of time.

background = pseudoabsencemask(WithinRadius, presencelayer; distance = 30.0)

# The pseudo-absence generation functions will return a *mask*, *i.e.* a boolean
# layer where the cells in which we can place a pseudo-absence are `true`, and the
# rest of the cells are `false`. This is useful for a variety of reasons,
# including adding more and more constraints to the locations of pseudo-absences.
# For example, we can decide that we do not want background points too close to
# the actual observations, and put a buffer around each.

buffer = pseudoabsencemask(WithoutRadius, presencelayer; distance = 5.0)

# We can now exclude the data that are in the buffer:

bgmask = background & buffer

# Finally, we can plot the area in which we can put pseudo-absences as a shaded region over
# the layer, and plot all known occurrences as well:

# fig-known-occurrences
heatmap(
    temperature;
    colormap = :deep,
    axis = (; aspect = DataAspect()),
    figure = (; size = (800, 500)),
)
heatmap!(bgmask; colormap = cgrad([:transparent, :white]; alpha = 0.3))
scatter!(presences; color = :black)
current_figure() #hide

# Note that we can get the same information by using the `BetweenRadius` method:

pseudoabsencemask(BetweenRadius, presencelayer; closer = 5.0, further = 30.0)

# Or even by getting the distances directly

pseudoabsencemask(DistanceToEvent, presencelayer; closer = 5.0, further = 30.0)

# There are additional ways to produce pseudo-absences mask, notably the surface range
# envelope method, which uses the bounding box of observations to allow pseudo-absences:

sre = pseudoabsencemask(SurfaceRangeEnvelope, presencelayer)

#-

# fig-background-mask
heatmap(
    temperature;
    colormap = :deep,
    axis = (; aspect = DataAspect()),
    figure = (; size = (800, 500)),
)
heatmap!(sre; colormap = cgrad([:transparent, :white]; alpha = 0.3))
scatter!(presences; color = :black)
current_figure() #hide

# The `RandomSelection` method (not shown) uses the entire surface of the layer as
# a possible pseudo-absence location.

# Note that we are not *yet* generating pseudo-absences, and in order to do so, we
# need to sample the mask generated by `pseudoabsencemask`. We can do so using
# `backgroundpoints`, which uses the `StatsBase.sample` function internally.

bgpoints = backgroundpoints(bgmask, sum(presencelayer))

# And finally, we can make a plot:

# fig-pseudoabsences
heatmap(
    temperature;
    colormap = :deep,
    axis = (; aspect = DataAspect()),
    figure = (; size = (800, 500)),
)
heatmap!(bgmask; colormap = cgrad([:transparent, :white]; alpha = 0.3))
scatter!(presences; color = :black)
scatter!(bgpoints; color = :red, markersize = 4)
current_figure() #hide


# There are additional ways to produce pseudo-absences mask, notably the surface range
# envelope method, which uses the bounding box of observations to allow pseudo-absences:

sre = pseudoabsencemask(SurfaceRangeEnvelope, presencelayer)

#-

# fig-background-mask
heatmap(
    temperature;
    colormap = :deep,
    axis = (; aspect = DataAspect()),
    figure = (; size = (800, 500)),
)
heatmap!(sre; colormap = cgrad([:transparent, :white]; alpha = 0.3))
scatter!(presences; color = :black)
current_figure() #hide


# ## Related documentation

# ```@meta
# CollapsedDocStrings = true
# ```

# ```@docs; canonical=false
# PseudoAbsences.PseudoAbsenceGenerator
# PseudoAbsences.WithinRadius
# PseudoAbsences.WithoutRadius
# PseudoAbsences.BetweenRadius
# PseudoAbsences.WithinDegrees
# PseudoAbsences.WithoutDegrees
# PseudoAbsences.BetweenDegrees
# PseudoAbsences.SurfaceRangeEnvelope
# PseudoAbsences.RandomSelection
# PseudoAbsences.DistanceToEvent
# PseudoAbsences.DegreesToEvent
# PseudoAbsences.pseudoabsencemask
# PseudoAbsences.backgroundpoints
# ```
